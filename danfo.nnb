{
    "cells": [
        {
            "language": "typescript",
            "source": [
                "import * as dfd from \"danfojs-node\"\nconst tf = dfd.tensorflow\n\nasync function load_process_data() {\n    let df = await dfd.readCSV(\"https://web.stanford.edu/class/archive/cs/cs109/cs109.1166/stuff/titanic.csv\")\n\n    //A feature engineering: Extract all titles from names columns\n    let title = df['Name'].apply((x) => { return x.split(\".\")[0] }).values\n    //replace in df\n    df.addColumn(\"Name\",  title, { inplace: true })\n\n    //label Encode Name feature\n    let encoder = new dfd.LabelEncoder()\n    let cols = [\"Sex\", \"Name\"]\n    cols.forEach(col => {\n        encoder.fit(df[col])\n        const enc_val = encoder.transform(df[col])\n        df.addColumn( col, enc_val, { inplace: true })\n    })\n\n\n    let Xtrain, ytrain;\n    Xtrain = df.iloc({ columns: [`1:`] })\n    ytrain = df['Survived']\n\n    // Standardize the data with MinMaxScaler\n    let scaler = new dfd.MinMaxScaler()\n    scaler.fit(Xtrain)\n    Xtrain = scaler.transform(Xtrain)\n    return [Xtrain.tensor, ytrain.tensor] //return the data as tensors\n}\n\nload_process_data()\n\n\nfunction get_model() {\n    const model = tf.sequential();\n    model.add(tf.layers.dense({ inputShape: [7], units: 124, activation: 'relu', kernelInitializer: 'leCunNormal' }));\n    model.add(tf.layers.dense({ units: 64, activation: 'relu' }));\n    model.add(tf.layers.dense({ units: 32, activation: 'relu' }));\n    model.add(tf.layers.dense({ units: 1, activation: \"sigmoid\" }))\n    model.summary();\n    return model\n}\n\nasync function train() {\n    const model = await get_model()\n    const data = await load_process_data()\n    const Xtrain = data[0]\n    const ytrain = data[1]\n\n    model.compile({\n        optimizer: \"rmsprop\",\n        loss: 'binaryCrossentropy',\n        metrics: ['accuracy'],\n    });\n\n    console.log(\"Training started....\")\n    await model.fit(Xtrain, ytrain,{\n        batchSize: 32,\n        epochs: 15,\n        validationSplit: 0.2,\n        callbacks:{\n            onEpochEnd: async(epoch, logs)=>{\n                console.log(`EPOCH (${epoch + 1}): Train Accuracy: ${(logs.acc * 100).toFixed(2)},\n                                                     Val Accuracy:  ${(logs.val_acc * 100).toFixed(2)}\\n`);\n            }\n        }\n    });\n};\n\ntrain()"
            ],
            "outputs": []
        }
    ]
}